{"mode":"Text","textContent":"#pragma region VEXcode Generated Robot Configuration\n// Make sure all required headers are included.\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// Brain should be defined by default\nbrain Brain;\n\n\n// START V5 MACROS\n#define waitUntil(condition)                                                   \\\n  do {                                                                         \\\n    wait(5, msec);                                                             \\\n  } while (!(condition))\n\n#define repeat(iterations)                                                     \\\n  for (int iterator = 0; iterator < iterations; iterator++)\n// END V5 MACROS\n\n\n// Robot configuration code.\nmotor RightDrive1 = motor(PORT10, ratio6_1, false);\n\nmotor RightDrive2 = motor(PORT9, ratio6_1, true);\n\nmotor RightDrive3 = motor(PORT8, ratio6_1, false);\n\nmotor LeftDrive1 = motor(PORT20, ratio6_1, true);\n\nmotor LeftDrive2 = motor(PORT19, ratio6_1, true);\n\nmotor LeftDrive3 = motor(PORT17, ratio6_1, false);\n\ncontroller Controller1 = controller(primary);\nmotor C1 = motor(PORT13, ratio36_1, false);\n\nmotor Intake = motor(PORT5, ratio18_1, false);\n\ndigital_out Matic = digital_out(Brain.ThreeWirePort.A);\ndistance Forward = distance(PORT1);\ndistance Back = distance(PORT2);\ndistance Right = distance(PORT3);\ndistance Left = distance(PORT4);\ninertial Inert = inertial(PORT14);\n\nmotor C2 = motor(PORT15, ratio36_1, true);\n\n\n\n\n// Helper to make playing sounds from the V5 in VEXcode easier and\n// keeps the code cleaner by making it clear what is happening.\nvoid playVexcodeSound(const char *soundName) {\n  printf(\"VEXPlaySound:%s\\n\", soundName);\n  wait(5, msec);\n}\n\n\n\n// define variable for remote controller enable/disable\nbool RemoteControlCodeEnabled = true;\n\n#pragma endregion VEXcode Generated Robot Configuration\n// ---- START VEXCODE CONFIGURED DEVICES ----// Robot Configuration:// [Name] [Type] [Port(s)]// LeftDrive1 motor 1 // LeftDrive2 motor 2 // LeftDrive3 motor 3 // RightDrive1 motor 4 // RightDrive2 motor 5 // RightDrive3 motor 6 // Cata motor 7 // Intake motor 8 // Controller1 controller // ---- END VEXCODE CONFIGURED DEVICES ----\n#include \"vex.h\"\n#include <vector>\n#include <cmath>\n#include <numeric>\n#include <string>\n#include <iostream>\n\nusing namespace std;\nusing namespace vex;\ncompetition Competition;\nvoid straight(double distance, int speed) {\nLeftDrive1.spinFor(distance, deg, speed, velocityUnits::pct, false);\nLeftDrive2.spinFor(distance, deg, speed, velocityUnits::pct, false);\nLeftDrive3.spinFor(distance, deg, speed, velocityUnits::pct, false);\nRightDrive1.spinFor(distance, deg, speed, velocityUnits::pct, false);\nRightDrive2.spinFor(distance, deg, speed, velocityUnits::pct, false);\nRightDrive3.spinFor(distance, deg, speed, velocityUnits::pct, true);\n}\n\n//motor_group LeftDrive = motor_group(LeftDrive1, LeftDrive2, LeftDrive3);\n//motor_group RightDrive = motor_group(RightDrive1, RightDrive2, RightDrive3);\nmotor_group LeftDrive = motor_group(LeftDrive1, LeftDrive2, LeftDrive3);\nmotor_group RightDrive = motor_group(RightDrive1, RightDrive2, RightDrive3);\nmotor_group Cata = motor_group(C1,C2);\n\nlong double pi = atan(1)*4;\n\nvoid cataDown(){\n Cata.spin(directionType::rev, 70, velocityUnits::pct);\n   wait(5, seconds);\n  Cata.stop(brakeType::hold); \n\n}\n\nbool open = true;\nvoid pneum(){\n  Matic.set(open);\n  open = !open;\n}\n\nvoid pneumopen(){\n\tMatic.set(true);\n}\n\nvoid pneumclose(){\n  Matic.set(false);\n}\n\nvoid RightTurn(int turn){\n  RightDrive.setVelocity(turn, percent);\n  LeftDrive.setVelocity(turn, percent);\n  RightDrive.spin(reverse);\n  LeftDrive.spin(fwd);\n}\n\nvoid LeftTurn(int turn){\n  RightDrive.setVelocity(turn, percent);\n  LeftDrive.setVelocity(turn, percent);\n  RightDrive.spin(fwd);\n  LeftDrive.spin(reverse);\n}\n\nvoid stopMotors(vex::brakeType b){\n  LeftDrive.stop(b);\n  RightDrive.stop(b);\n}\n\nvoid RightAcc(double spinner){\n  Inert.setRotation(0, degrees);\n\n    int dt = 20;  // Recommended wait time in milliseconds\n  double target = spinner; // In revolutions\n  double error = target - Inert.rotation();\n  double tP = .147; //.17\n  double tD = 0.035; //.035\n  double prevError = error;\n\n  double timeElap = 0;\n\n  while (timeElap < 1400) {\n    error = target - Inert.rotation();\n    double derivative = (error - prevError)/dt;\n    double percent1 = tP * error + tD * derivative;\n\n    Brain.Screen.printAt(20, 40, \"Inertial: %f\", Inert.rotation());\n    Brain.Screen.printAt(20, 40, \"Power: %f\", Inert.rotation());\n\n    RightTurn(percent1);\n\n    vex::task::sleep(dt);\n    prevError = error;\n\n    timeElap += dt;\n  }\n  stopMotors(hold);\n}\n\nvoid LeftAcc(double spinner){\n  Inert.setRotation(0, degrees);\n\n  int dt = 20;  // Recommended wait time in milliseconds\n  double target = spinner; // In revolutions\n  double error = target - Inert.rotation();\n  double tP = .147; //.17\n  double tD = 0.035; //.035\n  double prevError = error;\n\n  double timeElap = 0;\n\n  while (timeElap < 1400) {\n    error = target - Inert.rotation();\n    double derivative = (error - prevError)/dt;\n    double percent2 = tP * error + tD * derivative;\n\n    Brain.Screen.printAt(20, 40, \"Inertial: %f\", Inert.rotation());\n\n    LeftTurn(percent2);\n\n    vex::task::sleep(dt);\n    prevError = error;\n\n    timeElap += dt;\n  }\n  stopMotors(hold);\n}\n\n\nvoid pre_auton(void) {\n  Inert.calibrate();\n}\n\n\nvoid autonomous(void) {\nInert.calibrate();\nCata.setVelocity(75, percent);\nLeftDrive.setVelocity(50, percent);\nRightDrive.setVelocity(50, percent);\n\nstraight(-220, 50);\nLeftAcc(40);\nstraight(-2600, 60);\nstraight(500, 30);\n\nRightAcc(180);\nRightAcc(135);\n\nstraight(-1100, 30); // touches matchloading bar\nRightAcc(85);\nstraight(-100, 40);\nCata.setVelocity(50, percent);\n//Matchloading\nCata.spin(fwd);\nwait(40, seconds); //30 matchloading\nCata.stop(hold);\nstraight(1000, 100);\nRightAcc(90);\nRightAcc(45);\n\nstraight(1200, 50);\nLeftAcc(42.8);\n\ndouble x = 1.8; // Change this value\nCata.setVelocity(10, percent);\nwhile(Cata.torque(Nm) < x){\n  Cata.spin(fwd); //Moves cata down enough to go under bar\n}\n  Cata.stop(hold);\n\nstraight(1000, 30);\nstraight(5750, 30); //touches opposite side matchloading bar and rotates 45 degrees\nstraight(-3500, 40); //moves straight touching middle bar\nRightAcc(22.5); //aligns straight on with the goal\npneumopen(); //extends pneumatics\n\nstraight(-4000, 30);\nstraight(2000, 30);\nstraight(-2000, 30);\nstraight(2000, 30); //pushes in and out of goal twice\n\nLeftAcc(45); //moves 45 degrees to the left\npneumclose();\n\nstraight(-2800, 30);\n\nRightAcc(90);\nRightAcc(45);\n\nstraight(1500, 40); //pushes in from the left side of the goal\n}\n\nbool shooting = false;\nvoid cataShoot(){\nCata.setVelocity(50, percent);\nwhile(true){\n  while(Controller1.ButtonL1.pressing()){\n    Cata.spin(fwd);\n}\n if(Controller1.ButtonY.pressing()){\n    shooting = !shooting;\n    wait(0.1, seconds);\n  }  \n  if(shooting){\n    Cata.spin(fwd);\n\n  } else{\n    Cata.stop(hold);}}}\n\nint counter = 0;\nvoid driveDirection(){\n  counter++;\n}\n\nvoid drivercontrol() {\n  thread CATA = thread(cataShoot); //Y sets cata shooting, and L1 held shoots\nController1.ButtonX.pressed(pneum); //Opens/closes pneumatics\nController1.ButtonA.pressed(driveDirection); //Changes which side of the drive is forward\n\n while (true) {\n\nif(counter % 2 == 1){\n\nLeftDrive.spin(fwd, Controller1.Axis3.position(), pct);\nRightDrive.spin(fwd, Controller1.Axis2.position(), pct);\n\n} else {\n\nLeftDrive.spin(reverse, Controller1.Axis2.position(), pct);\nRightDrive.spin(reverse, Controller1.Axis3.position(), pct);\n\n}\n\nif(Controller1.ButtonR1.pressing()){\n Intake.spin(reverse, 100, pct);\n}\nelse if(Controller1.ButtonR2.pressing()){\n Intake.spin(fwd, 100, pct);\n}\nelse{\nIntake.stop(brakeType::hold);\nwait(0.1, msec);\n}\nwait(5, msec);\n}}\n\nint main(){\n  Competition.autonomous(autonomous);\n  Competition.drivercontrol(drivercontrol);\npre_auton();\nwait(10, msec);\n}\n\n","textLanguage":"cpp","rconfig":[{"port":[10],"name":"RightDrive1","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[9],"name":"RightDrive2","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[8],"name":"RightDrive3","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[20],"name":"LeftDrive1","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[19],"name":"LeftDrive2","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[17],"name":"LeftDrive3","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[],"name":"Controller1","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"none","id":"primary"},"triportSourcePort":22},{"port":[13],"name":"C1","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio36_1"},"triportSourcePort":22},{"port":[5],"name":"Intake","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[1],"name":"Matic","customName":true,"deviceType":"DigitalOut","deviceClass":"digital_out","setting":{"id":"partner"},"triportSourcePort":22},{"port":[1],"name":"Forward","customName":true,"deviceType":"Distance","deviceClass":"distance","setting":{"id":"partner"},"triportSourcePort":22},{"port":[2],"name":"Back","customName":true,"deviceType":"Distance","deviceClass":"distance","setting":{"id":"partner"},"triportSourcePort":22},{"port":[3],"name":"Right","customName":true,"deviceType":"Distance","deviceClass":"distance","setting":{"id":"partner"},"triportSourcePort":22},{"port":[4],"name":"Left","customName":true,"deviceType":"Distance","deviceClass":"distance","setting":{"id":"partner"},"triportSourcePort":22},{"port":[14],"name":"Inert","customName":true,"deviceType":"Inertial","deviceClass":"inertial","setting":{"id":"partner"},"triportSourcePort":22},{"port":[15],"name":"C2","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio36_1"},"triportSourcePort":22}],"slot":0,"platform":"V5","sdkVersion":"20240219.10.00.00","appVersion":"3.1.0","minVersion":"3.1.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false,"target":"Physical"}